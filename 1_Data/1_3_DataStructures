# Data sctructures

## Tuples
Tuples are similars to lists, but can have elements of different types!

### syntax
```
(elem1, elem2, ..., elemN)
```

### Methods
This only works with tuples of EXACTLY two elements.
```
ghci> fst ('x', True)
'x'
ghci> snd ('x', True)
True
```

### Working with tuples

#### returning
```
splitAtPos3 :: [Int] -> ([Int], [Int])
splitAtPos3 l = (take 3 l, drop 3 l)
```

#### matching
```
showTriple :: (Bool, Int, String) -> String
showTriple (b, n, string) =
  if b
    then "The number is: " ++ show n
    else "The string is: " ++ string
```

```
ghci> showTriple (False, 42, "hello")
"The string is: hello"
ghci> showTriple (True, 42, "hello")
"The number is: 42"
```

## Algebraic Data Type (ADT)
A type formed by combining other types using either *product* or *sum* types.

By using the **data** keyword we can achieve this, creating our own data types.

### Product type
- Combining types using both
- Zero or more types combined

#### data: Product
```
data User = MkUser String Int Bool
```
- **User**: *data type* name
- **MkUser**: *constructor* name
- **String Int Bool** *field* types

Our data type User will have 3 fields, one of type String, one Int and one Bool.

Getters and setters for the new data type.
```
data User = MkUser String Int Bool
  deriving (Show) -- to display our type in GHCi

-- Getters
getUserName :: User -> String
getUserName (MkUser name _ _) = name

getUserAge :: User -> Int
getUserAge (MkUser _ age _) = age

-- Setters - values in Haskell are immutable! So return a new User
setUserName :: String -> User -> User
setUserName name (MkUser _ age isTired) = MkUser name age isTired
```

##### data: Records
If there is to many fields the syntax we have seen until now will be really inconvenient, Haskell has **Records** for that.
```
data User = MkUser
  { userName :: String,
    userAge :: Int,
    userIsTired :: Bool
  }
```

This syntax also autogenerates top-level functions, so no need to write the basic getters.
```
userName :: User -> String
userAge :: User -> Int
userIsTired :: User -> Bool
```

It also lets creating new records from other records, by writing the other value name and after it the changed values in curly braces.
```
ghci> john = MkUser {userName = "John", userAge = 30, userIsTired = True}
ghci> userName john
"John"
ghci> kevin = john {userName = "Kevin", userAge = 20}
ghci> userName kevin
"Kevin"
```

### Sum type
Choice of types, either one or another

#### Defining a sum type
```
data Result
  = Error String
  | Ok Int
```
```
divide :: Int -> Int -> Result
divide _ 0 = Error "Division by zero!"
divide x y = Ok (div x y)
```

#### Enumerations
Enumerations are an example of sum type
```
data Color
  = Red
  | Blue
  | Green
```
```
showColor :: Color -> String
showColor color = case color of
  Red -> "red"
  Blue -> "blue"
  Green -> "green"
```
